#!/bin/sh
printHelp(){
    cat << EOF
Create a bootable media from a Windows® 10 iso image
Usage:
  $(basename "$0") -i <iso-image> -d <device> [OPTIONS]

  -i, --iso-image FILE      iso image to be used in the media creation
  -d, --device    DEVICE    device where the image must be burnt

  Optional parameters:

  -h, --help                display a help message like this
  -v, --verbose             turn on verbose output
  -V, --version             print molotov version and exit
  -u, --uefi                make an uefi-bootable media
                            (default is legacy)

Mandatory or optional arguments to long options are also mandatory 
or optional for any corresponding short options.

Report bugs to <https://github.com/cizordj/molotov>

EOF
exit 0
}

printVersion(){
    cat << EOF
Molotov 0.6.4

Copyright (C) Cézar Augusto de Campos
License: MIT
EOF
exit 0
}

handleArguments(){
    test ! $# -gt 0
    THERE_IS_NO_ARGUMENT=$?
    VERBOSE=1
    UEFI=1

    while true
    do
        if [ $THERE_IS_NO_ARGUMENT -eq 0 ]; then
            printHelp
        elif [ "$1" = "-h" ] || [ "$1" = "help" ] || [ "$1" = "--help" ]; then
            printHelp
        elif [ "$1" = "-i" ] || [ "$1" = "iso-image" ] || [ "$1" = "--iso-image" ]; then
            shift 1
            ISO_IMAGE="$1"
        elif [ "$1" = "-d" ] || [ "$1" = "device" ] || [ "$1" = "--device" ]; then
            shift 1
            TARGET_DEVICE="$1"
        elif [ "$1" = "-u" ] || [ "$1" = "uefi" ] || [ "$1" = "--uefi" ]; then
            UEFI=0
            printOut "Uefi mode enabled\n"
        elif [ "$1" = "-V" ] || [ "$1" = "version" ] || [ "$1" = "--version" ]; then
            printVersion
        elif [ "$1" = "-v" ] || [ "$1" = "verbose" ] || [ "$1" = "--verbose" ]; then
            VERBOSE=0
        elif [ $# -gt 0 ]; then
            printErr "Unknown option: $1\n"
            exit 64
        else
            break
        fi
        shift 1
    done

    if [ ! -e "$ISO_IMAGE" ] || [ -z "$ISO_IMAGE" ]; then
        printErr "Iso image file not found: $ISO_IMAGE\n"
        exit 66
    elif [ ! -e "$TARGET_DEVICE" ]; then
        printErr "The specified device was not found: $TARGET_DEVICE\n"
        exit 67
    fi
}

printErr(){
    >&2 printf '%b' "$@"
}

checkSuperUser(){
    if [ "$(id -u)" -ne 0 ]; then
        printErr "Insufficient permissions\n"
        exit 68
    fi
}

umountDevice(){
    printOut "Umounting $TARGET_DEVICE and $ISO_IMAGE\n"
    umount -q "$ISO_IMAGE" "$TARGET_DEVICE"*
    printOut "Removing $ISO_MOUNTPOINT and $DEVICE_MOUNTPOINT\n"
    rmdir "$ISO_MOUNTPOINT" "$DEVICE_MOUNTPOINT" 2> /dev/null
}

printOut(){
    if [ $VERBOSE -eq 0 ]; then
        printf '%b' "$@"
    fi
}

formatDeviceForUefi(){
    printOut "Removing file system signature from $TARGET_DEVICE\n"
    wipefs --quiet --all "$TARGET_DEVICE"
    sfdisk -q "$TARGET_DEVICE" << EOF
label: gpt
device: $TARGET_DEVICE
unit: sectors
first-lba: 2048
sector-size: 512

$TARGET_PARTITION : start= 2048, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B  
EOF
    printOut "Formatting $TARGET_PARTITION with FAT32\n"
    mkfs.fat -n "$DISK_LABEL" -F 32 "$TARGET_PARTITION"
}

formatDeviceForCsm(){
    printOut "Removing file system signature from $TARGET_DEVICE\n"
    wipefs --quiet --all "$TARGET_DEVICE"
    sfdisk -q "$TARGET_DEVICE" << EOF
label: dos
device: $TARGET_DEVICE
unit: sectors
sector-size: 512
$TARGET_PARTITION : start= 2048, type=7, bootable
EOF
    printOut "Formatting $TARGET_PARTITION with NTFS\n"
    mkfs.ntfs --label "$DISK_LABEL" --fast --quiet "$TARGET_PARTITION"
}

mountDevice(){ 
    printOut "Mounting $TARGET_DEVICE and $ISO_IMAGE\n"
    mkdir -p "$ISO_MOUNTPOINT" "$DEVICE_MOUNTPOINT"
    mount --read-only --source "$ISO_IMAGE" --target "$ISO_MOUNTPOINT"
    mount --source "$TARGET_PARTITION" --target "$DEVICE_MOUNTPOINT"
}

dumpImageToDevice(){
    countFiles(){
        find "$ISO_MOUNTPOINT" -type f | wc -l
    }
    copyFiles(){
        rsync -vrW --no-compress "$ISO_MOUNTPOINT/" "$DEVICE_MOUNTPOINT/"
    }
    total=$(countFiles)
    pointer=1

    printOut "Dumping image to $TARGET_PARTITION\n"

    copyFiles | while read in
    do
        unset in
        printOut "\r$(( pointer * 100 / total))%"
        pointer=$(( pointer + 1 ))
        if [ "$pointer" -eq "$total" ]
        then
            break
        fi
    done
    printOut "\n"
}

makeDeviceBootable(){
    generate_config(){
        cat << EOF
DEFAULT windows
SAY Initializing Windows, this might take a while
LABEL windows
  COM32 /boot/syslinux/chain.c32
  APPEND fs ntldr=/bootmgr
EOF
} 
    copy_syslinux_modules(){
        MODULES="chain.c32 libcom32.c32 libutil.c32 ldlinux.c32"
        for MODULE in $MODULES
        do
            printOut "Copying $MODULE to $BOOT_DIRECTORY\n"
            cp "$(find /usr  -name "$MODULE" | grep "/bios/")" -t "$BOOT_DIRECTORY"
        done
    }
    find_syslinux_mbr(){
        find /usr -name "mbr.bin" | grep "/syslinux/"
    }
    printOut "Making $TARGET_DEVICE bootable with syslinux\n"
    BOOT_DIRECTORY="$DEVICE_MOUNTPOINT/boot/syslinux"
    mkdir -p "$BOOT_DIRECTORY"
    extlinux --install "$BOOT_DIRECTORY"
    dd if="$(find_syslinux_mbr)" of="$TARGET_DEVICE" bs=440 count=1 conv=notrunc status=none
    printOut "Generating syslinux.cfg\n"
    generate_config > "$BOOT_DIRECTORY/syslinux.cfg"
}

handleArguments "$@"
checkSuperUser

DEVICE_MOUNTPOINT="/tmp/DEVICE_MOUNTPOINT"
DISK_LABEL="WINDOWS10"
ISO_MOUNTPOINT="/tmp/ISO_MOUNTPOINT"
PARTITION_NUMBER=1
TARGET_PARTITION="$TARGET_DEVICE$PARTITION_NUMBER"

umountDevice

if [ $UEFI -eq 0 ]; then
    formatDeviceForUefi
else
    formatDeviceForCsm
fi

mountDevice
dumpImageToDevice

if [ $UEFI -eq 1 ]; then
    makeDeviceBootable
fi 

umountDevice
exit 0
